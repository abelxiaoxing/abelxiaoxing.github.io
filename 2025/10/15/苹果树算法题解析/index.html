<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"abelxiaoxing.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="🍎 问题描述 融合了概率论、期望计算的奇怪算法题，回到了高中数学的感觉。">
<meta property="og:type" content="article">
<meta property="og:title" content="苹果树算法题解析">
<meta property="og:url" content="https://abelxiaoxing.github.io/2025/10/15/%E8%8B%B9%E6%9E%9C%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="abel的小天地">
<meta property="og:description" content="🍎 问题描述 融合了概率论、期望计算的奇怪算法题，回到了高中数学的感觉。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-15T06:56:56.000Z">
<meta property="article:modified_time" content="2025-10-16T03:11:58.844Z">
<meta property="article:author" content="abelxiaoxing">
<meta property="article:tag" content="算法题">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://abelxiaoxing.github.io/2025/10/15/%E8%8B%B9%E6%9E%9C%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://abelxiaoxing.github.io/2025/10/15/%E8%8B%B9%E6%9E%9C%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90/","path":"2025/10/15/苹果树算法题解析/","title":"苹果树算法题解析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>苹果树算法题解析 | abel的小天地</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">abel的小天地</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">🍎 问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E9%A2%98%E7%9B%AE%E4%BB%8E%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">理解题目：从具体例子开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF%E8%BD%AC%E6%8D%A2%E4%BB%8E%E7%82%B9%E5%AF%B9%E8%B7%9D%E7%A6%BB%E5%88%B0%E8%BE%B9%E5%81%9A%E8%B4%A1%E7%8C%AE"><span class="nav-number">3.</span> <span class="nav-text">核心思路转换：从”点对距离”到”边做贡献”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%84%A6%E5%8D%95%E6%9D%A1%E8%BE%B9%E5%88%86%E6%9E%90%E5%AD%90%E6%A0%91%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%9C%9F%E6%9C%9B"><span class="nav-number">4.</span> <span class="nav-text">聚焦单条边：分析子树大小的期望</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E6%9C%9F%E6%9C%9B%E5%80%BC%E6%9C%80%E5%85%B3%E9%94%AE%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC"><span class="nav-number">5.</span> <span class="nav-text">求解期望值：最关键的数学推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E8%AF%A6%E8%A7%A3"><span class="nav-number">6.</span> <span class="nav-text">公式推导详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7"><span class="nav-number">6.1.</span> <span class="nav-text">预备知识与核心工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%8E%A8%E5%AF%BC%E5%AD%90%E6%A0%91%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%9C%9F%E6%9C%9B-ex_t"><span class="nav-number">6.2.</span> <span class="nav-text">第一部分：推导子树大小的期望
E[Xt]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B-s_m-%E5%92%8C-s_m-1-%E7%9A%84%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">6.2.1.</span> <span class="nav-text">1. 建立 Sm 和 Sm − 1
的递推关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97-es_m-s_m-1"><span class="nav-number">6.2.2.</span> <span class="nav-text">2. 计算 E[Sm|Sm − 1]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3-e_m-%E7%9A%84%E9%80%92%E6%8E%A8%E5%BC%8F"><span class="nav-number">6.2.3.</span> <span class="nav-text">3. 求解 Em
的递推式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%80%BC-e_t"><span class="nav-number">6.2.4.</span> <span class="nav-text">4. 确定初始值 Et</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%97%E5%88%B0%E6%9C%80%E7%BB%88%E5%85%AC%E5%BC%8F"><span class="nav-number">6.2.5.</span> <span class="nav-text">5. 得到最终公式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%8E%A8%E5%AF%BC%E5%AD%90%E6%A0%91%E5%A4%A7%E5%B0%8F%E5%B9%B3%E6%96%B9%E7%9A%84%E6%9C%9F%E6%9C%9B-ex_t2"><span class="nav-number">6.3.</span> <span class="nav-text">第二部分：推导子树大小平方的期望
E[Xt2]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B-s_m2-%E5%92%8C-s_m-12-%E7%9A%84%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">6.3.1.</span> <span class="nav-text">1. 建立 Sm2
和 Sm − 12
的递推关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97-es_m2-s_m-1"><span class="nav-number">6.3.2.</span> <span class="nav-text">2. 计算 E[Sm2|Sm − 1]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3-a_m-%E7%9A%84%E9%80%92%E6%8E%A8%E5%BC%8F"><span class="nav-number">6.3.3.</span> <span class="nav-text">3. 求解 Am
的递推式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E8%AF%A5%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E5%BC%8F%E5%B9%B6%E5%BE%97%E5%88%B0%E6%9C%80%E7%BB%88%E5%85%AC%E5%BC%8F"><span class="nav-number">6.3.4.</span> <span class="nav-text">4.
求解该线性递推式并得到最终公式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%B1%82%E8%A7%A3%E9%80%92%E6%8E%A8%E6%96%B9%E7%A8%8B"><span class="nav-number">6.3.4.1.</span> <span class="nav-text">目标：求解递推方程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E6%8E%A8%E5%AF%BC%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.4.</span> <span class="nav-text">详细推导步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%B0%86%E6%96%B9%E7%A8%8B%E6%A0%87%E5%87%86%E5%8C%96"><span class="nav-number">6.4.1.</span> <span class="nav-text">第一步：将方程标准化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E5%AF%BB%E6%89%BE%E6%B1%82%E5%92%8C%E5%9B%A0%E5%AD%90"><span class="nav-number">6.4.2.</span> <span class="nav-text">第二步：寻找求和因子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%BA%94%E7%94%A8%E6%B1%82%E5%92%8C%E5%9B%A0%E5%AD%90%E5%B9%B6%E6%B1%82%E5%92%8C"><span class="nav-number">6.4.3.</span> <span class="nav-text">第三步：应用求和因子并求和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E5%90%88%E5%B9%B6%E5%B9%B6%E6%B1%82%E8%A7%A3-a_n"><span class="nav-number">6.4.4.</span> <span class="nav-text">第四步：合并并求解 AN</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%E6%B1%87%E6%80%BB%E4%B8%8E%E8%AE%A1%E7%AE%97"><span class="nav-number">7.</span> <span class="nav-text">第五步：汇总与计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.</span> <span class="nav-text">如何处理精度问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.</span> <span class="nav-text">算法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">7.3.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">abelxiaoxing</p>
  <div class="site-description" itemprop="description">一个个人资料记录的小地方</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://abelxiaoxing.github.io/2025/10/15/%E8%8B%B9%E6%9E%9C%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="abelxiaoxing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="abel的小天地">
      <meta itemprop="description" content="一个个人资料记录的小地方">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="苹果树算法题解析 | abel的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          苹果树算法题解析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-15 14:56:56" itemprop="dateCreated datePublished" datetime="2025-10-15T14:56:56+08:00">2025-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-16 11:11:58" itemprop="dateModified" datetime="2025-10-16T11:11:58+08:00">2025-10-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="问题描述">🍎 问题描述</h2>
<p>融合了<strong>概率论</strong>、<strong>期望计算</strong>的奇怪算法题，回到了高中数学的感觉。
<span id="more"></span> ## 算法题目</p>
<p>小
C在自己家的花园里种了一棵苹果树，树上每个结点都有恰好两个分支。经过细心的观察，小
C发现每一天这棵树都会生长出一个新的结点。</p>
<p><strong>生长规则：</strong> - <strong>第一天：</strong>
花园里什么都没有，我们种下第一颗种子，它长成了树的根。这个根结点很特殊，它有两个空位，可以用来长新的树枝。我们称这些空位为”插槽”。
- <strong>第二天及以后：</strong>
每一天，果树会随机选择一个当前树中没有长出过结点的分支，然后在这个分支上长出一个新结点，新结点与分支所属的结点之间连接上一条边。</p>
<p><strong>不便度定义：</strong>
树上两两结点之间的距离之和，两个结点之间的距离定义为从一个点走到另一个点的路径经过的边数。</p>
<p><strong>求解目标：</strong> 计算 N 天后不便度的期望 E，并求 E × N! 对
P 取模的结果。</p>
<p><strong>数据范围：</strong> <span
class="math inline">1 ≤ <em>N</em> ≤ 2000</span>，<span
class="math inline">1 ≤ <em>P</em> ≤ 10<sup>9</sup> + 7</span></p>
<p>输入样例1： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 610745795</span><br></pre></td></tr></table></figure> 输出样例1： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure></p>
<p>输入样例2： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">305 1000000007</span><br></pre></td></tr></table></figure> 输出样例2： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">865018107</span><br></pre></td></tr></table></figure></p>
<h2 id="理解题目从具体例子开始">理解题目：从具体例子开始</h2>
<p>让我们通过一个具体的例子来理解这个过程：</p>
<p><strong>第一天 (N=1)：</strong>
花园里什么都没有，我们种下第一颗种子，它长成了树的根。这个根结点很特殊，它有两个空位，可以用来长新的树枝。我们称这些空位为”插槽”。</p>
<p><strong>第二天 (N=2)：</strong>
现在树上总共有2个空”插槽”。大自然会完全随机地从这2个插槽中选1个，让它长出一个新的苹果结点。现在树上有2个结点了。新长出的这个结点，自己又带来了2个新的空插槽。而被占用的那个老插槽消失了。</p>
<p><strong>第三天 (N=3)：</strong> 我们来算一下现在有几个空插槽。 -
根结点有2个，被用掉了1个，剩下1个。 - 第二天的新结点，自己带来了2个。 -
总共就是 1 + 2 = 3 个空插槽。 -
大自然再次从这3个空插槽里完全随机地选1个，长出第三个结点。</p>
<p><strong>规律发现：</strong> 你会发现一个规律，当树上有 k
个结点时，总会有 k+1 个空插槽可供选择。这个过程会一直持续到第 N
天，最终形成一棵有 N 个结点的树。</p>
<p>“不便度”是什么？不便度就是树上任意两个苹果（结点）之间的距离之和。比如苹果A到苹果B要经过3条树枝，那它们之间的距离就是3。我们要把所有这种”A到B”的距离都加起来。</p>
<p><strong>目标是什么？</strong>
因为树的生长是随机的，所以每次长出来的树的形状可能都不一样，从而”不便度”也不同。题目要求我们计算这个”不便度”在所有可能情况下的平均值，也就是期望
(E)。最后，因为结果可能是分数，题目让我们计算 E × N!
对P取模后的结果。</p>
<h2
id="核心思路转换从点对距离到边做贡献">核心思路转换：从”点对距离”到”边做贡献”</h2>
<p>直接计算所有点对距离的期望非常复杂。这里有一个非常经典且重要的转化思想：考虑每一条边的贡献。</p>
<p>现在，我们换个角度。我们不看点，而是看每一条边，问一个问题：“这条边，在我们的总距离计算中，被用到了多少次？”把所有边的贡献加起来，就是总的不便度。</p>
<p>想象一下，把树上的一条边砍断，这棵树会立刻分成两半。假设左半部分有 a
个结点，右半部分有 b 个结点（显然 a+b=N）。</p>
<ul>
<li>任何一个左边的点要走到右边的点，都必须经过刚才被我们砍断的这条边。</li>
<li>左边有 a 个点，右边有 b 个点，所以总共有 a * b
对这样的”跨边点对”。</li>
<li>因此，这条边对总的”不便度”的贡献正好是 a * b。</li>
</ul>
<p><strong>总不便度 = 所有边的贡献之和 = Σ
(每条边连接的两侧结点数的乘积)</strong></p>
<p>这个结论至关重要，它把一个复杂的问题简化为了对每一条边进行分析。</p>
<p>将复杂的全局距离计算转化为局部边贡献的累加，为后续的期望分析奠定了基础。</p>
<h2
id="聚焦单条边分析子树大小的期望">聚焦单条边：分析子树大小的期望</h2>
<p>我们的树是按天生长的。我们考虑在第 t 天（t
从2到N）长出来的那条边。这条边连接了一个父节点和一个在第 t
天新生成的子节点。</p>
<p>这条边将整棵树（N个结点）分成了两部分： - 以这个第 t
天的新结点为根的子树。 - 树的其余部分。</p>
<p>我们令 <span
class="math inline"><em>X</em><sub><em>t</em></sub></span>
表示到第N天结束时，这个子树最终的大小（包含多少个结点）。那么，树的其余部分大小就是
<span
class="math inline"><em>N</em> − <em>X</em><sub><em>t</em></sub></span>。根据上一步的结论，这条边在第N天对总不便度的贡献就是
<span
class="math inline"><em>X</em><sub><em>t</em></sub> * (<em>N</em> − <em>X</em><sub><em>t</em></sub>)</span>。</p>
<p>因为树的生长是随机的，<span
class="math inline"><em>X</em><sub><em>t</em></sub></span>
的值也是不确定的。所以我们需要计算它的期望贡献：<span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub> * (<em>N</em> − <em>X</em><sub><em>t</em></sub>)]</span>。</p>
<p>根据期望的性质，<span
class="math inline"><em>E</em>[<em>A</em> * <em>B</em>]</span>
不一定等于 <span
class="math inline"><em>E</em>[<em>A</em>] * <em>E</em>[<em>B</em>]</span>，但
<span
class="math inline"><em>E</em>[<em>c</em> * <em>A</em> − <em>A</em><sup>2</sup>]</span>
(c是常数) 等于 <span
class="math inline"><em>c</em> * <em>E</em>[<em>A</em>] − <em>E</em>[<em>A</em><sup>2</sup>]</span>。所以，我们有：
<span
class="math display"><em>E</em>[<em>X</em><sub><em>t</em></sub> * (<em>N</em> − <em>X</em><sub><em>t</em></sub>)] = <em>E</em>[<em>N</em> * <em>X</em><sub><em>t</em></sub> − <em>X</em><sub><em>t</em></sub><sup>2</sup>] = <em>N</em> * <em>E</em>[<em>X</em><sub><em>t</em></sub>] − <em>E</em>[<em>X</em><sub><em>t</em></sub><sup>2</sup>]</span>
现在，问题变成了：对于第 t 天加入的结点，其最终子树大小的期望 <span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub>]</span>
和平方的期望 <span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub><sup>2</sup>]</span>
是多少？</p>
<h2 id="求解期望值最关键的数学推导">求解期望值：最关键的数学推导</h2>
<p>这一步是整个解法的核心，我们来理解这些公式是怎么来的。</p>
<p>我们不直接研究子树大小 <span
class="math inline"><em>X</em><sub><em>t</em></sub></span>，而是研究一个更方便的量：子树的空插槽数量。一个包含
<span class="math inline"><em>k</em></span> 个结点的子树，总是有 <span
class="math inline"><em>k</em> + 1</span> 个空插槽。所以，<span
class="math inline"><em>X</em><sub><em>t</em></sub> = (<em>最</em><em>终</em><em>子</em><em>树</em><em>的</em><em>空</em><em>插</em><em>槽</em><em>数</em>) − 1</span>。</p>
<p><strong>初始状态：</strong> 在第 <span
class="math inline"><em>t</em></span> 天，当结点 <span
class="math inline"><em>t</em></span>
刚被创建时，它自己是一个大小为1的子树，拥有2个空插槽。</p>
<p><strong>演化过程：</strong> 从第 <span
class="math inline"><em>t</em></span> 天到第 <span
class="math inline"><em>N</em></span>
天，每天都会有一个新结点加入。假设在第 <span
class="math inline"><em>m</em></span> 天（<span
class="math inline"><em>m</em> &gt; <em>t</em></span>），树上总共有
<span class="math inline"><em>m</em></span> 个结点和 <span
class="math inline"><em>m</em> + 1</span> 个空插槽。 - 我们的子树当前有
<span class="math inline"><em>S</em><sub><em>m</em> − 1</sub></span>
个空插槽。 - 新结点长到我们子树里的概率是 <span
class="math inline">$\frac{S_{m-1}}{m}$</span> (子树插槽数 / 总插槽数)。
- 如果长进来了，子树的空插槽数会加1（失去1个旧的，得到2个新的）。 -
如果没长进来，子树的空插槽数不变。</p>
<p>通过这个概率过程，使用数学方法（条件期望和递推），可以精确地推导出：</p>
<p><strong>子树大小的期望 (E[X_t]):</strong> <span
class="math display">$$E[X_t] = \left(\frac{2 * (N+1)}{(t+1)}\right) -
1$$</span></p>
<p><strong>子树大小平方的期望 (E[X_t^2]):</strong> <span
class="math display">$$E[X_t^2] = 1 + \frac{6 * (N+1) * (N-t)}{(t+1) *
(t+2)}$$</span></p>
<h2 id="公式推导详解">公式推导详解</h2>
<p>以下是这两个关键公式的详细推导过程：</p>
<h3 id="预备知识与核心工具"><strong>预备知识与核心工具</strong></h3>
<p>在开始之前，我们需要明确我们的核心工具：<strong>条件期望定律</strong>（或称<strong>全期望定律</strong>）。它的思想很简单：想求一个变量的期望，可以先”固定”某个相关的条件，求出在该条件下它的期望，然后再对这个条件本身求期望。</p>
<p>数学上写为：<span
class="math inline"><em>E</em>[<em>Y</em>] = <em>E</em>[<em>E</em>[<em>Y</em>|<em>Z</em>]]</span>。
在我们这里，就是 <span
class="math inline"><em>E</em>[<em>S</em><sub><em>m</em></sub>] = <em>E</em>[<em>E</em>[<em>S</em><sub><em>m</em></sub>|<em>S</em><sub><em>m</em> − 1</sub>]]</span>。意思是，想知道
<span class="math inline"><em>m</em></span> 时刻的期望，我们可以先看看在
<span class="math inline"><em>m</em> − 1</span> 时刻 <span
class="math inline"><em>S</em><sub><em>m</em> − 1</sub></span>
取某个具体值 <span class="math inline"><em>s</em></span> 的情况下 <span
class="math inline"><em>S</em><sub><em>m</em></sub></span>
的期望是多少，然后再对 <span
class="math inline"><em>S</em><sub><em>m</em> − 1</sub></span>
的所有可能取值 <span class="math inline"><em>s</em></span> 求平均。</p>
<p><strong>变量定义</strong>： - <span
class="math inline"><em>S</em><sub><em>m</em></sub></span>: 在整棵树有
<span class="math inline"><em>m</em></span>
个结点时，我们所关注的、以结点 <span
class="math inline"><em>t</em></span>
为根的子树拥有的<strong>空插槽数量</strong>。 - <span
class="math inline"><em>E</em><sub><em>m</em></sub></span>: <span
class="math inline"><em>S</em><sub><em>m</em></sub></span> 的期望，即
<span
class="math inline"><em>E</em>[<em>S</em><sub><em>m</em></sub>]</span>。
- <span class="math inline"><em>A</em><sub><em>m</em></sub></span>:
<span
class="math inline"><em>S</em><sub><em>m</em></sub><sup>2</sup></span>
的期望，即 <span
class="math inline"><em>E</em>[<em>S</em><sub><em>m</em></sub><sup>2</sup>]</span>。</p>
<hr />
<h3
id="第一部分推导子树大小的期望-ex_t"><strong>第一部分：推导子树大小的期望
<span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub>]</span></strong></h3>
<p>我们的目标是求出 <span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub>]</span>。我们知道
<span
class="math inline"><em>X</em><sub><em>t</em></sub> = <em>S</em><sub><em>N</em></sub> − 1</span>，所以关键是求
<span
class="math inline"><em>E</em>[<em>S</em><sub><em>N</em></sub>]</span>。</p>
<h4 id="建立-s_m-和-s_m-1-的递推关系"><strong>1. 建立 <span
class="math inline"><em>S</em><sub><em>m</em></sub></span> 和 <span
class="math inline"><em>S</em><sub><em>m</em> − 1</sub></span>
的递推关系</strong></h4>
<p>考虑从第 <span class="math inline"><em>m</em> − 1</span> 天到第 <span
class="math inline"><em>m</em></span> 天，树上增加了一个新结点。 - 在第
<span class="math inline"><em>m</em> − 1</span> 天结束时，树上共有 <span
class="math inline"><em>m</em> − 1</span> 个结点，总空插槽数为 <span
class="math inline">(<em>m</em> − 1) + 1 = <em>m</em></span> 个。 -
我们关注的子树有 <span
class="math inline"><em>S</em><sub><em>m</em> − 1</sub></span>
个空插槽。 - 第 <span class="math inline"><em>m</em></span>
个结点会从全部 <span class="math inline"><em>m</em></span>
个空插槽中等概率随机选择一个。</p>
<p>现在，我们来计算 <span
class="math inline"><em>S</em><sub><em>m</em></sub></span>
的值。这取决于新结点落在哪里：</p>
<ul>
<li><strong>情况A：新结点落在我们的子树内部。</strong>
<ul>
<li>这个事件发生的概率是 <span class="math inline">$P_A =
\frac{S_{m-1}}{m}$</span>。</li>
<li>如果发生，子树失去1个旧插槽，但新结点带来2个新插槽。所以子树的插槽数净增1。</li>
<li>此时，<span
class="math inline"><em>S</em><sub><em>m</em></sub> = <em>S</em><sub><em>m</em> − 1</sub> + 1</span>。</li>
</ul></li>
<li><strong>情况B：新结点落在我们的子树外部。</strong>
<ul>
<li>这个事件发生的概率是 <span class="math inline">$P_B = 1 -
\frac{S_{m-1}}{m}$</span>。</li>
<li>如果发生，子树的插槽数不变。</li>
<li>此时，<span
class="math inline"><em>S</em><sub><em>m</em></sub> = <em>S</em><sub><em>m</em> − 1</sub></span>。</li>
</ul></li>
</ul>
<h4 id="计算-es_m-s_m-1"><strong>2. 计算 <span
class="math inline"><em>E</em>[<em>S</em><sub><em>m</em></sub>|<em>S</em><sub><em>m</em> − 1</sub>]</span></strong></h4>
<p>根据条件期望的定义，我们固定 <span
class="math inline"><em>S</em><sub><em>m</em> − 1</sub></span>
的值，计算 <span
class="math inline"><em>S</em><sub><em>m</em></sub></span> 的期望：
<span class="math display">$$
\begin{aligned}
E[S_m | S_{m-1}] &amp;= (S_{m-1} + 1) \cdot P_A + (S_{m-1}) \cdot P_B \\
&amp;= (S_{m-1} + 1) \cdot \frac{S_{m-1}}{m} + S_{m-1} \cdot \left(1 -
\frac{S_{m-1}}{m}\right) \\
&amp;= \frac{S_{m-1}^2 + S_{m-1}}{m} + S_{m-1} - \frac{S_{m-1}^2}{m} \\
&amp;= S_{m-1} + \frac{S_{m-1}}{m} \\
&amp;= S_{m-1} \cdot \frac{m+1}{m}
\end{aligned}
$$</span></p>
<h4 id="求解-e_m-的递推式"><strong>3. 求解 <span
class="math inline"><em>E</em><sub><em>m</em></sub></span>
的递推式</strong></h4>
<p>现在使用全期望定律： <span
class="math inline"><em>E</em><sub><em>m</em></sub> = <em>E</em>[<em>S</em><sub><em>m</em></sub>] = <em>E</em>[<em>E</em>[<em>S</em><sub><em>m</em></sub>|<em>S</em><sub><em>m</em> − 1</sub>]]</span>
<span class="math inline">$E_m = E\left[S_{m-1} \cdot
\frac{m+1}{m}\right]$</span></p>
<p>因为 <span class="math inline">$\frac{m+1}{m}$</span>
是一个常数，可以提出来： <span class="math inline">$E_m = \frac{m+1}{m}
\cdot E[S_{m-1}] = \frac{m+1}{m} \cdot E_{m-1}$</span></p>
<p>这是一个非常简洁的递推关系！我们可以把它展开： <span
class="math display">$$
E_m = \frac{m+1}{m} E_{m-1} = \frac{m+1}{m} \cdot \frac{m}{m-1} E_{m-2}
= \dots
$$</span>
这是一个<strong>连乘</strong>的形式。我们一直展开到我们的<strong>初始时刻</strong>，也就是第
<span class="math inline"><em>t</em></span> 天。 <span
class="math display">$$
E_m = E_t \cdot \frac{t+2}{t+1} \cdot \frac{t+3}{t+2} \cdot \dots \cdot
\frac{m}{m-1} \cdot \frac{m+1}{m}
$$</span> 观察这个连乘，中间项会全部约掉（比如 <span
class="math inline"><em>t</em> + 2</span> 和 <span
class="math inline"><em>t</em> + 2</span> 约掉），只剩下头尾： <span
class="math display">$$
E_m = E_t \cdot \frac{m+1}{t+1}
$$</span></p>
<h4 id="确定初始值-e_t"><strong>4. 确定初始值 <span
class="math inline"><em>E</em><sub><em>t</em></sub></span></strong></h4>
<p>在第 <span class="math inline"><em>t</em></span> 天，结点 <span
class="math inline"><em>t</em></span>
刚刚被创建。它自己构成了大小为1的子树。这个子树有 <strong>2</strong>
个空插槽。这是一个确定的值，不是随机的。 所以 <span
class="math inline"><em>S</em><sub><em>t</em></sub> = 2</span>，因此
<span
class="math inline"><em>E</em><sub><em>t</em></sub> = <em>E</em>[<em>S</em><sub><em>t</em></sub>] = 2</span>。</p>
<p>代入上式，我们得到 <span
class="math inline"><em>E</em><sub><em>m</em></sub></span> 的通项公式：
<span class="math display">$$
E_m = 2 \cdot \frac{m+1}{t+1}
$$</span></p>
<h4 id="得到最终公式"><strong>5. 得到最终公式</strong></h4>
<p>我们需要的是第 <span class="math inline"><em>N</em></span>
天的情况，所以令 <span
class="math inline"><em>m</em> = <em>N</em></span>： <span
class="math display">$$E[S_N] = 2 \cdot \frac{N+1}{t+1}$$</span></p>
<p>最后，转换回子树大小 <span
class="math inline"><em>X</em><sub><em>t</em></sub></span>： <span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub>] = <em>E</em>[<em>S</em><sub><em>N</em></sub> − 1] = <em>E</em>[<em>S</em><sub><em>N</em></sub>] − 1</span>
<span class="math display">$$
\boxed{E[X_t] = \frac{2(N+1)}{t+1} - 1}
$$</span></p>
<hr />
<h3
id="第二部分推导子树大小平方的期望-ex_t2"><strong>第二部分：推导子树大小平方的期望
<span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub><sup>2</sup>]</span></strong></h3>
<p>这个过程类似，但计算会更复杂一些。我们的目标是求 <span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub><sup>2</sup>]</span>，这需要我们先求出
<span
class="math inline"><em>A</em><sub><em>N</em></sub> = <em>E</em>[<em>S</em><sub><em>N</em></sub><sup>2</sup>]</span>。</p>
<h4 id="建立-s_m2-和-s_m-12-的递推关系"><strong>1. 建立 <span
class="math inline"><em>S</em><sub><em>m</em></sub><sup>2</sup></span>
和 <span
class="math inline"><em>S</em><sub><em>m</em> − 1</sub><sup>2</sup></span>
的递推关系</strong></h4>
<p>我们还是利用情况A和情况B： - <strong>情况A</strong> (概率 <span
class="math inline">$\frac{S_{m-1}}{m}$</span>): <span
class="math inline"><em>S</em><sub><em>m</em></sub> = <em>S</em><sub><em>m</em> − 1</sub> + 1</span>，所以
<span
class="math inline"><em>S</em><sub><em>m</em></sub><sup>2</sup> = (<em>S</em><sub><em>m</em> − 1</sub> + 1)<sup>2</sup> = <em>S</em><sub><em>m</em> − 1</sub><sup>2</sup> + 2<em>S</em><sub><em>m</em> − 1</sub> + 1</span>。
- <strong>情况B</strong> (概率 <span class="math inline">$1 -
\frac{S_{m-1}}{m}$</span>): <span
class="math inline"><em>S</em><sub><em>m</em></sub> = <em>S</em><sub><em>m</em> − 1</sub></span>，所以
<span
class="math inline"><em>S</em><sub><em>m</em></sub><sup>2</sup> = <em>S</em><sub><em>m</em> − 1</sub><sup>2</sup></span>。</p>
<h4 id="计算-es_m2-s_m-1"><strong>2. 计算 <span
class="math inline"><em>E</em>[<em>S</em><sub><em>m</em></sub><sup>2</sup>|<em>S</em><sub><em>m</em> − 1</sub>]</span></strong></h4>
<p><span class="math display">$$
\begin{aligned}
E[S_m^2 | S_{m-1}] &amp;= (S_{m-1}^2 + 2S_{m-1} + 1) \cdot
\frac{S_{m-1}}{m} + (S_{m-1}^2) \cdot \left(1 - \frac{S_{m-1}}{m}\right)
\\
&amp;= \left(\frac{S_{m-1}^3}{m} + \frac{2S_{m-1}^2}{m} +
\frac{S_{m-1}}{m}\right) + \left(S_{m-1}^2 - \frac{S_{m-1}^3}{m}\right)
\\
&amp;= S_{m-1}^2 + \frac{2}{m}S_{m-1}^2 + \frac{1}{m} S_{m-1} \\
&amp;= \left(1 + \frac{2}{m}\right) S_{m-1}^2 + \frac{1}{m} S_{m-1}
\end{aligned}
$$</span></p>
<h4 id="求解-a_m-的递推式"><strong>3. 求解 <span
class="math inline"><em>A</em><sub><em>m</em></sub></span>
的递推式</strong></h4>
<p>使用全期望定律： <span
class="math inline"><em>A</em><sub><em>m</em></sub> = <em>E</em>[<em>S</em><sub><em>m</em></sub><sup>2</sup>] = <em>E</em>[<em>E</em>[<em>S</em><sub><em>m</em></sub><sup>2</sup>|<em>S</em><sub><em>m</em> − 1</sub>]]</span>
<span class="math inline">$A_m = E\left[\left(1 + \frac{2}{m}\right)
S_{m-1}^2 + \frac{1}{m} S_{m-1}\right]$</span></p>
<p>根据期望的线性性质 <span
class="math inline"><em>E</em>[<em>a</em><em>Y</em> + <em>b</em><em>Z</em>] = <em>a</em><em>E</em>[<em>Y</em>] + <em>b</em><em>E</em>[<em>Z</em>]</span>：
<span class="math display">$$
A_m = \left(1 + \frac{2}{m}\right) E[S_{m-1}^2] + \frac{1}{m} E[S_{m-1}]
$$</span> <span class="math display">$$
A_m = \frac{m+2}{m} A_{m-1} + \frac{1}{m} E_{m-1}
$$</span> 我们已经求出了 <span class="math inline">$E_{m-1} = 2 \cdot
\frac{m}{t+1}$</span>。<strong>注意这里需要使用 <span
class="math inline"><em>m</em></span> 而不是 <span
class="math inline"><em>m</em> − 1</span></strong>： <span
class="math display">$$
E_{m-1} = 2 \cdot \frac{(m-1)+1}{t+1} = 2 \cdot \frac{m}{t+1}
$$</span></p>
<p>代入上式： <span class="math display">$$
A_m = \frac{m+2}{m} A_{m-1} + \frac{1}{m} \cdot \frac{2m}{t+1}
$$</span> <span class="math display">$$
A_m = \frac{m+2}{m} A_{m-1} + \frac{2}{t+1}
$$</span></p>
<p>这是一个一阶线性非齐次递推方程，需要用标准方法求解。</p>
<h4 id="求解该线性递推式并得到最终公式"><strong>4.
求解该线性递推式并得到最终公式</strong></h4>
<h5 id="目标求解递推方程"><strong>目标：求解递推方程</strong></h5>
<p>我们要解决的递推关系是： <span class="math display">$$
A_m = \frac{m+2}{m} A_{m-1} + \frac{2}{t+1} \quad (m &gt; t)
$$</span> 其初始条件为<strong>第 t 天</strong>的情况。在第 t
天，子树就是结点 t 本身，它有 <span
class="math inline"><em>S</em><sub><em>t</em></sub> = 2</span>
个确定的空插槽。因此， <span
class="math display"><em>A</em><sub><em>t</em></sub> = <em>E</em>[<em>S</em><sub><em>t</em></sub><sup>2</sup>] = 2<sup>2</sup> = 4</span></p>
<p>这是一个<strong>一阶线性非齐次递推方程</strong>。我们将使用<strong>求和因子</strong>
的标准方法来求解它，这种方法类似于求解线性微分方程时使用的积分因子法。</p>
<h3 id="详细推导步骤"><strong>详细推导步骤</strong></h3>
<h4 id="第一步将方程标准化"><strong>第一步：将方程标准化</strong></h4>
<p>首先，我们将所有与 <span class="math inline"><em>A</em></span>
相关的项移到一边，写成标准形式 <span
class="math inline"><em>A</em><sub><em>m</em></sub> − <em>f</em>(<em>m</em>)<em>A</em><sub><em>m</em> − 1</sub> = <em>g</em>(<em>m</em>)</span>。
<span class="math display">$$
A_m - \frac{m+2}{m} A_{m-1} = \frac{2}{t+1}
$$</span></p>
<h4 id="第二步寻找求和因子"><strong>第二步：寻找求和因子</strong></h4>
<p>我们的目标是找到一个因子 <span
class="math inline"><em>I</em><sub><em>m</em></sub></span>，当它乘以方程两边后，左边可以“折叠”成一个单一的差分形式，即
<span
class="math inline"><em>B</em><sub><em>m</em></sub> − <em>B</em><sub><em>m</em> − 1</sub></span>
的样子。 我们希望： <span class="math display">$$
I_m \left( A_m - \frac{m+2}{m} A_{m-1} \right) = (I_m A_m) - (I_{m-1}
A_{m-1})
$$</span> 为了让这个等式成立，通过比较 <span
class="math inline"><em>A</em><sub><em>m</em> − 1</sub></span>
的系数，我们必须满足： <span class="math display">$$
I_m \frac{m+2}{m} = I_{m-1}
$$</span> 或者写成关于 <span
class="math inline"><em>I</em><sub><em>m</em></sub></span> 的递推式：
<span class="math display">$$
I_m = I_{m-1} \cdot \frac{m}{m+2}
$$</span> 我们可以通过连乘来解出 <span
class="math inline"><em>I</em><sub><em>m</em></sub></span>。为了方便，我们设定初始值
<span class="math inline"><em>I</em><sub><em>t</em></sub> = 1</span>。
<span class="math display">$$
\begin{aligned}
I_m &amp;= I_{m-1} \cdot \frac{m}{m+2} \\
&amp;= I_{m-2} \cdot \frac{m-1}{m+1} \cdot \frac{m}{m+2} \\
&amp;= \dots \\
&amp;= I_t \cdot \frac{t+1}{t+3} \cdot \frac{t+2}{t+4} \cdot \dots \cdot
\frac{m-1}{m+1} \cdot \frac{m}{m+2}
\end{aligned}
$$</span> 我们把分子和分母分别写出来： * <strong>分子</strong>: <span
class="math inline">(<em>t</em> + 1) ⋅ (<em>t</em> + 2) ⋅ (<em>t</em> + 3) ⋅ … ⋅ <em>m</em></span>
* <strong>分母</strong>: <span
class="math inline">(<em>t</em> + 3) ⋅ (<em>t</em> + 4) ⋅ … ⋅ <em>m</em> ⋅ (<em>m</em> + 1) ⋅ (<em>m</em> + 2)</span></p>
<p>可以看到，从 <span class="math inline">(<em>t</em> + 3)</span> 到
<span class="math inline"><em>m</em></span>
的所有项在分子和分母中都存在，可以约分。约分后剩下： <span
class="math display">$$
I_m = I_t \cdot \frac{(t+1)(t+2)}{(m+1)(m+2)}
$$</span> 由于我们设定了 <span
class="math inline"><em>I</em><sub><em>t</em></sub> = 1</span>，所以求和因子就是：
<span class="math display">$$
I_m = \frac{(t+1)(t+2)}{(m+1)(m+2)}
$$</span></p>
<h4
id="第三步应用求和因子并求和"><strong>第三步：应用求和因子并求和</strong></h4>
<p>我们将原始方程 <span class="math inline">$A_m - \frac{m+2}{m} A_{m-1}
= \frac{2}{t+1}$</span> 的两边都乘以求和因子 <span
class="math inline"><em>I</em><sub><em>m</em></sub></span>： <span
class="math display">$$
I_m A_m - I_m \frac{m+2}{m} A_{m-1} = I_m \frac{2}{t+1}
$$</span> 根据我们构造 <span
class="math inline"><em>I</em><sub><em>m</em></sub></span>
的方式，左边变成了 <span
class="math inline"><em>I</em><sub><em>m</em></sub><em>A</em><sub><em>m</em></sub> − <em>I</em><sub><em>m</em> − 1</sub><em>A</em><sub><em>m</em> − 1</sub></span>。所以：
<span class="math display">$$
I_m A_m - I_{m-1} A_{m-1} = \frac{(t+1)(t+2)}{(m+1)(m+2)} \cdot
\frac{2}{t+1} = \frac{2(t+2)}{(m+1)(m+2)}
$$</span> 现在，我们将这个方程从 <span
class="math inline"><em>m</em> = <em>t</em> + 1</span> 到 <span
class="math inline"><em>N</em></span> 进行求和： <span
class="math display">$$
\sum_{m=t+1}^{N} (I_m A_m - I_{m-1} A_{m-1}) = \sum_{m=t+1}^{N}
\frac{2(t+2)}{(m+1)(m+2)}
$$</span> 左边是一个<strong>伸缩求和 (Telescoping Sum)</strong>： <span
class="math display">(<em>I</em><sub><em>t</em> + 1</sub><em>A</em><sub><em>t</em> + 1</sub> − <em>I</em><sub><em>t</em></sub><em>A</em><sub><em>t</em></sub>) + (<em>I</em><sub><em>t</em> + 2</sub><em>A</em><sub><em>t</em> + 2</sub> − <em>I</em><sub><em>t</em> + 1</sub><em>A</em><sub><em>t</em> + 1</sub>) + … + (<em>I</em><sub><em>N</em></sub><em>A</em><sub><em>N</em></sub> − <em>I</em><sub><em>N</em> − 1</sub><em>A</em><sub><em>N</em> − 1</sub>) = <em>I</em><sub><em>N</em></sub><em>A</em><sub><em>N</em></sub> − <em>I</em><sub><em>t</em></sub><em>A</em><sub><em>t</em></sub></span>
右边可以提出常数项： <span class="math display">$$
2(t+2) \sum_{m=t+1}^{N} \frac{1}{(m+1)(m+2)}
$$</span> 我们使用<strong>部分分式分解</strong>来处理求和内部的项：<span
class="math inline">$\frac{1}{(m+1)(m+2)} = \frac{1}{m+1} -
\frac{1}{m+2}$</span>。 所以右边的和也是一个伸缩求和： <span
class="math display">$$
\begin{aligned}
\sum_{m=t+1}^{N} \left(\frac{1}{m+1} - \frac{1}{m+2}\right) &amp;=
\left(\frac{1}{t+2} - \frac{1}{t+3}\right) + \left(\frac{1}{t+3} -
\frac{1}{t+4}\right) + \dots + \left(\frac{1}{N+1} -
\frac{1}{N+2}\right) \\
&amp;= \frac{1}{t+2} - \frac{1}{N+2}
\end{aligned}
$$</span></p>
<h4 id="第四步合并并求解-a_n"><strong>第四步：合并并求解 <span
class="math inline"><em>A</em><sub><em>N</em></sub></span></strong></h4>
<p>现在，我们将左右两边的结果合并： <span class="math display">$$
I_N A_N - I_t A_t = 2(t+2) \left( \frac{1}{t+2} - \frac{1}{N+2} \right)
$$</span> <span class="math display">$$
I_N A_N - I_t A_t = 2 - \frac{2(t+2)}{N+2}
$$</span></p>
<p>代入我们已知的值： * <span class="math inline">$I_N =
\frac{(t+1)(t+2)}{(N+1)(N+2)}$</span> * <span
class="math inline"><em>I</em><sub><em>t</em></sub> = 1</span> * <span
class="math inline"><em>A</em><sub><em>t</em></sub> = 4</span></p>
<p><span class="math display">$$
\frac{(t+1)(t+2)}{(N+1)(N+2)} A_N - 4 = 2 - \frac{2(t+2)}{N+2}
$$</span></p>
<p>现在，我们解出 <span
class="math inline"><em>A</em><sub><em>N</em></sub></span>： <span
class="math display">$$
\frac{(t+1)(t+2)}{(N+1)(N+2)} A_N = 6 - \frac{2(t+2)}{N+2}
$$</span></p>
<p>将右边通分： <span class="math display">$$
6 - \frac{2(t+2)}{N+2} = \frac{6(N+2) - 2(t+2)}{N+2} = \frac{6N + 12 -
2t - 4}{N+2} = \frac{6N - 2t + 8}{N+2}
$$</span></p>
<p>于是有： <span class="math display">$$
\frac{(t+1)(t+2)}{(N+1)(N+2)} A_N = \frac{6N - 2t + 8}{N+2}
$$</span></p>
<p>将 <span class="math inline"><em>A</em><sub><em>N</em></sub></span>
的系数移到右边： <span class="math display">$$
A_N = \frac{(N+1)(N+2)}{(t+1)(t+2)} \cdot \frac{6N - 2t + 8}{N+2}
$$</span></p>
<p><span class="math display">$$
A_N = \frac{(N+1)(6N - 2t + 8)}{(t+1)(t+2)}
$$</span></p>
<p>现在，转换回 <span
class="math inline"><em>X</em><sub><em>t</em></sub><sup>2</sup></span>：</p>
<p>我们有 <span
class="math inline"><em>X</em><sub><em>t</em></sub> = <em>S</em><sub><em>N</em></sub> − 1</span>，所以：
<span
class="math display"><em>E</em>[<em>X</em><sub><em>t</em></sub><sup>2</sup>] = <em>E</em>[(<em>S</em><sub><em>N</em></sub> − 1)<sup>2</sup>] = <em>E</em>[<em>S</em><sub><em>N</em></sub><sup>2</sup> − 2<em>S</em><sub><em>N</em></sub> + 1] = <em>E</em>[<em>S</em><sub><em>N</em></sub><sup>2</sup>] − 2<em>E</em>[<em>S</em><sub><em>N</em></sub>] + 1</span></p>
<p>我们已知： - <span class="math inline">$E[S_N^2] = A_N =
\frac{(N+1)(6N - 2t + 8)}{(t+1)(t+2)}$</span> - <span
class="math inline">$E[S_N] = 2 \cdot \frac{N+1}{t+1}$</span></p>
<p>代入计算： <span class="math display">$$
\begin{aligned}
E[X_t^2] &amp;= \frac{(N+1)(6N - 2t + 8)}{(t+1)(t+2)} - 2 \cdot
\frac{2(N+1)}{t+1} + 1 \\
&amp;= \frac{(N+1)(6N - 2t + 8)}{(t+1)(t+2)} - \frac{4(N+1)}{t+1} + 1 \\
&amp;= \frac{(N+1)(6N - 2t + 8) - 4(N+1)(t+2)}{(t+1)(t+2)} + 1 \\
&amp;= \frac{(N+1)[6N - 2t + 8 - 4t - 8]}{(t+1)(t+2)} + 1 \\
&amp;= \frac{(N+1)(6N - 6t)}{(t+1)(t+2)} + 1 \\
&amp;= \frac{6(N+1)(N - t)}{(t+1)(t+2)} + 1
\end{aligned}
$$</span></p>
<p>最终得到： <span class="math display">$$
\boxed{E[X_t^2] = 1 + \frac{6(N+1)(N-t)}{(t+1)(t+2)}}
$$</span></p>
<h2 id="第五步汇总与计算">第五步：汇总与计算</h2>
<p>现在我们拥有了所有工具：</p>
<p><strong>总不便度的期望 <span
class="math inline"><em>E</em> = <em>Σ</em><em>E</em>[<em>第</em><em>t</em><em>条</em><em>边</em><em>的</em><em>贡</em><em>献</em>](<em>从</em><em>t</em> = 2<em>到</em><em>N</em>)</span></strong></p>
<p><strong>每条边的期望贡献 <span
class="math inline"><em>C</em><sub><em>t</em></sub> = <em>N</em> * <em>E</em>[<em>X</em><sub><em>t</em></sub>] − <em>E</em>[<em>X</em><sub><em>t</em></sub><sup>2</sup>]</span></strong></p>
<p>所以，我们只需要写一个循环，<span
class="math inline"><em>t</em></span> 从 2 遍历到 <span
class="math inline"><em>N</em></span>： 1. 根据上面的公式计算出 <span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub>]</span>
和 <span
class="math inline"><em>E</em>[<em>X</em><sub><em>t</em></sub><sup>2</sup>]</span>。
2. 计算出这条边的期望贡献 <span
class="math inline"><em>N</em> * <em>E</em>[<em>X</em><sub><em>t</em></sub>] − <em>E</em>[<em>X</em><sub><em>t</em></sub><sup>2</sup>]</span>。
3. 把这个贡献累加到总期望 <span class="math inline"><em>E</em></span>
中。</p>
<h3 id="如何处理精度问题">如何处理精度问题？</h3>
<p>在计算过程中，会出现大量的分数。使用Python的 fractions.Fraction
模块。这个模块可以精确地处理分数运算，不会有任何精度损失。</p>
<ul>
<li>我们用 Fraction 对象来存储 E 和中间计算结果。</li>
<li>循环结束后，我们得到一个精确的分数 E。</li>
<li>题目要求 E × N! 对 P 取模。我们可以先计算 E *
N!。由于题目的保证，这个结果一定是个整数。</li>
<li>最后，将这个整数结果对 P 取模。</li>
</ul>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_E_times_factorial_mod</span>(<span class="params">N, P</span>):</span><br><span class="line">    E = Fraction(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">        Ex = Fraction(<span class="number">2</span> * (N + <span class="number">1</span>), t + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        Ex2 = Fraction(<span class="number">1</span>, <span class="number">1</span>) + Fraction(<span class="number">6</span> * (N + <span class="number">1</span>) * (N - t), (t + <span class="number">1</span>) * (t + <span class="number">2</span>))</span><br><span class="line">        Ct = N * Ex - Ex2</span><br><span class="line">        E += Ct</span><br><span class="line"></span><br><span class="line">    val = E * math.factorial(N)</span><br><span class="line">    val_int = val.numerator // val.denominator</span><br><span class="line">    <span class="keyword">return</span> val_int % P</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = sys.stdin.read().strip().split()</span><br><span class="line">    N = <span class="built_in">int</span>(data[<span class="number">0</span>])</span><br><span class="line">    P = <span class="built_in">int</span>(data[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(compute_E_times_factorial_mod(N, P))</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><strong>时间复杂度：</strong> <span
class="math inline"><em>O</em>(<em>N</em>)</span>
<ul>
<li>主循环执行<span class="math inline"><em>N</em> − 1</span>次</li>
<li>每次迭代包含<span
class="math inline"><em>O</em>(1)</span>的算术运算</li>
</ul></li>
<li><strong>空间复杂度：</strong> <span
class="math inline"><em>O</em>(1)</span>
<ul>
<li>仅使用常数</li>
</ul></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98/" rel="tag"># 算法题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/09/Claude%20Code%20+%20%E9%AD%94%E6%90%AD%E7%A4%BE%E5%8C%BA%20API%EF%BC%9A%E5%85%8D%E8%B4%B9%E7%99%BD%E5%AB%96%E6%96%B0%E5%A7%BF%E5%8A%BF/" rel="prev" title="Claude Code + 魔搭社区 API：免费白嫖新姿势">
                  <i class="fa fa-angle-left"></i> Claude Code + 魔搭社区 API：免费白嫖新姿势
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">abelxiaoxing</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
